= Node-Js Api 101
:course-name: Node-js Api 101
:author: Robert Bornschein
:local: http://localhost:3000
:repl: https://repl.it/@rbrtbrnschn

== Table of contents

[upperroman]
. <<Setup>>
    ... <<Installing Node-Js>>
    ... <<Creating a project>>
    ... <<Npm scripts>>
. <<Whats an api, What's an api>>
    ... <<Simply put>>
    ... <<Good to know>>
. <<Lets get coding>>
    ... <<Hello world>>
    ... <<Get & Post>>
    ... <<Put Patch Delete & Options>>
    ... <<Parameters>>
    ... <<Query>>
    ... <<Cookies>>
    ... <<Databases>>
    ... <<Node-Fetch>>

== Setup

== Installing Node-Js

Since this is a `Node-Js` api which we are building, we need it installed.
To install it, please install https://github.com/nvm-sh/nvm[nvm]. +
*Nvm* is the node-version-manager, allows you to easily have different node versions installed and work with those seamlessly.

To verify the installation of node, you can run the following commands in the command-line.

```bash
node -v # v12.20.2
npm -v # 6.14.11
```

== Creating a project

Now that node is properly installed, we can move on to the fun part - setting up the project!
I will be going up this with the help of the command-line, feel free to manually click away!

[quote]
____
First things first.
____
```bash
# Creating a new directory

mkdir node-js-api
cd node-js-api

# Creaitng an npm project, and installing deps
npm init -y
npm i --save express \
  cors \
  cookie-parser \
  body-parser \
  node-fetch \
  dotenv \ 
  nodemon 
# Creating and writing to index.js
vi index.js
```

=== Index.js

```js
const express = require("express");
require("dotenv").config({path:__dirname});
const app = express();
const port = process.env.PORT || 3000;
const callback = (port) => console.log(`Running on port: ${port}`);

// This runs our server on port: port and takes in the callback callback
app.listen(port, callback(port));
```

== Npm scripts

== package.json 
```json
"scripts": {
    "test": "test script here",
    "dev": "nodemon"
}
```

Having added in that *dev* script, this now allows us to run *nodemon*. +
Nodemon restarts the server any time it detects a changed file. Meaning any time you save while editing, the server restarts. This takes out a lot of hassle from the workflow.

To start working it, run `npm run dev`.

== Whats an api

== Simply put
An api is simply an endpoint invisible to the day to day user, which usually communicates with your front end application (anything you can see on your screen).
For example, when you log in to your google account - and I am assuming you have one, because it's 2021 - when you enter your password and hit that login button. The frontend (so the login page, that you see), send that password to an API (a remote server) which authenticates it and sends back a response.
Now in the terms of a _google login_, an api would most likely send back a response code of `200`.
That means everything is okay - password is valid.
If it were anything else, the front application (your google login page), would say okay, that's apparently the wrong password - here try again.

== How does it do that?

An API always has a setup of endpoints. To understand an endpoint think of it like the url of a website you visit.
// example / and /user and so on

=== Good to know
// I dont even know

== Lets get coding

== Hello world

```js
/* Basic Routing: Accessible on http://localhost:3000/ */
/* Simple GET request */
app.get("/", (req,res) => {
    res.status(200).send("Hello World!");
})

/* Simple POST request */
app.post("/", (req,res) => {
    /* Access sent along data. */
    console.log(req.body)
    /* Access client's cookies */
    console.log(req.cookies);
    res.cookie("newCookie","newCookieValue", {maxAge: 3000});
    const objectOfYourChoice = {sample: true, error: "none"};
    return res.json(objectOfYourChoice);
})
```

Routes is a fairly simple topic. Once you host your api, you can reach it under all the endpoints you set up.
Endpoints are all the routes that you have setup. For example, we just setup our root path, meaning anyone who would go to {local}, would see the `Hello World`.
With the browser you can only ever *see* GET requests. 
We are currently hosting to endpoints on the same route ("/").
The one (GET) is globally accessible by browsers. The second (POST) is not.
Why is that you may ask?

== Get & Post

You see, when your browser is navigating to {local}, you will see the `Hello World` message printed to your screen. Once you reach an endpoint like a url, all the browser wants to do is *GET* the information on the site or the api. It doesn't care about what you can possibly *POST*.
This is where the client comes into play. You can use this *POST* mapping to communicate with your API. More often than not, APIs are used for authentication purposes.
With the example above you could possibly see how that would be done.
Within the endpoint for the *POST* mapping for "/", we can clearly access the users cookies and also set new ones. We also have access to what is called the "body" of a request.
This is where the user would send their password and username for example.

This way authentication is pretty simple. All you have to do is access your _database_, query for the username and see if the passwords match.
If so - great - set a new cookie on the user, so we will know he is properly authenticated.
If not you could simply return a bad status code like so `return res.status(403);`, meaing *FORBIDDEN*.

In general *GET* requests are used to, well get information. This doesn't necessarily have to html. It may also be a certain property within your database.
*POST* requests on the other hand will allow you to give along information, this opens up a lot of opportunities for you. This allows saving new data, as well as manipulating already exisitng data and so on.

== Put Patch Delete & Options

Technically there are 6 different kind of requests, whereas we have already covered _two_ in greater detail.
You also have *PUT, PATH & DELETE* request as far as our _normal_ one's go.
Those are similar to the already covered *POST* request.

*PUT* puts a data, such as a file or any other kind of resource at a specific URI. Also, it will replace the already exisiting file, if a new *PUT* request is sent. If there is no exisitng file, it will create one.

*PATCH* patches up exisiting data, it simply edits pre-exisiting files or data. It's really used to make minor updates.

*DELETE* should be self explanatory.

We do also have another one called *Options*, which will not go into any further detail on. Feel free to checkout https://www.baeldung.com/cs/why-options-request-sent[this resource] on it, if you fancy.


== Parameters 

Paramters can be used within routes as well.
Say for example you don't want to print `Hello World`,
but rather `Hello Peter`, or the name of the user.

It's rather simple to add that in. Take a look.

```js
app.get("/hello/:name", (req, res) => {
    const {params} = req;
    res.send(`Hello ${params.name}.`);
}) 
```
You simply add a ":" infront of the pathname. You can also add a "?" at the end to make it optional.
```js
app.get("/hello/:name/:optional?", (req,res) => {
  const {params} = req;
  const base = `Hello ${params.name}.`;
  let message = base;
  if(params.optional) {
    message += `\n How are you ${params.optional}?`
  } 
  return res.send(message);
})
```

== Query

You may previously seen this kind of url +
`https://youtube.com/search?q=Video+Name+Here`

This part: `?q=Video` is the query.

Why use a query? A query can be very dynamic, you can add all sorts of query options, making it perfect to give certain information to the backend.

Example use cases would the Youtube search bar. 
When you input your video name into it and hit enter or search, you will be redirected
to the same domain (`https://youtube.com`), but this time it also adds a query to that base url.
It may look something like in the example above.

Queries are usually used in `GET` requests, but are not limited to them.

To illustrate, say you have an array of user objects in your api code somewhere like so:

```js
const users = [{username: "pete"}, {username: "aubrey simmons"}, {username: "andrew"}];
```

Creating a get request that would return a single user, specified via query, may look like this.

```js
app.get("/users", (req,res) => {
    const {username} = req.query;
    return res.json(users.find((user) => user.username === username));
})
```
Unlike with paramters, you do not see them and thereby define them in the `path`. Meaning, you needn't add anything to `/users`. 
That is the route, any query is only an addition.

Now to get the user object with the `username` of "andrew" you would go to +
{local}/users?username=andrew&secondQuery=here

Say you want to search for `aubrey simmons`. Now that is a different story.

=== Url Encoding

There are only so many characters allowed in a `url`. A whitespace or space, is not permitted. Enter `url encoding`.

For example, to encode a whitespace in a url like `aubrey simmons`, we would have to write `aubrey%20simmons` or `aubrey+simmons`. Either will do the job.

Urls only accept alphanumerical characters as well as a set of 40 something reserved characters like `+` and `-` for example.

== Cookies

=== What are cookies.

> Cookies are usually small text files, given ID tags that are stored on your computer's browser directory or program data subfolders.

> Cookies are created when you use your browser to visit a website that uses cookies to keep track of your movements within the site, help you resume where you left off, remember your registered login, theme selection, preferences, and other customization functions.

=== Now how do we create some cookies?

```js
app.get("/cookie", (req,res)=>{
    const options = {expires: Date.now()+3e5}
    res.cookie("name",...options);
})


```
